**数据库的三大范式**是数据库设计中的基础原则，旨在减少数据冗余和提高数据的一致性。它们分别是：

1. **第一范式（1NF）**：确保每个列中的值是原子性的，不可再分的。每个表格中的列都只包含单一类型的值，每个字段不能包含多个值或列表。
**示例**：
```
违反1NF:
学生表：{学生ID, 学生姓名, 课程1, 课程2, 课程3}

满足1NF:
学生课程表：{学生ID, 学生姓名, 课程}

```
2.**第二范式（2NF）**：在满足第一范式的基础上，确保表中的每个非主键列完全依赖于主键，而不是部分依赖。也就是说，非主键列不能依赖于主键的一部分。
**示例**
```
违反2NF:
学生课程表：{学生ID, 课程ID, 课程名称, 教师姓名}

满足2NF:
学生课程表：{学生ID, 课程ID}
课程表：{课程ID, 课程名称, 教师姓名}
```
3.**第三范式（3NF）**：在满足第二范式的基础上，确保表中的每个非主键列都直接依赖于主键，而不是通过其他非主键列间接依赖。这意味着不存在传递依赖
**示例**：
```
违反3NF:
学生课程表：{学生ID, 课程ID, 课程名称, 教师姓名, 教师办公室}

满足3NF:
学生课程表：{学生ID, 课程ID}
课程表：{课程ID, 课程名称, 教师ID}
教师表：{教师ID, 教师姓名, 教师办公室}

```

**SQL行列转换**
行列转换在SQL中是一种常见的操作，通过条件聚合、UNION ALL和动态SQL等方法可以实现灵活的行列转换。根据具体的需求选择合适的方法，有助于提高查询的效率和可读性。
- **行转列（Pivot）**

	**示例数据**：

	假设有一个销售表 `sales`：
	
| Year | Month | Sales |
| ---- | ----- | ----- |
| 2023 | Jan   | 100   |
| 2023 | Feb   | 150   |
| 2023 | Mar   | 200   |
| 2024 | Jan   | 120   |
| 2024 | Feb   | 180   |
| 2024 | Mar   | 220   |

	我们希望将月份作为列，年作为行：

| Year | Jan | Feb | Mar |
| ---- | --- | --- | --- |
| 2023 | 100 | 150 | 200 |
| 2024 | 120 | 180 | 220 |

	在MySQL中，可以使用条件聚合来实现行转列：
```sql
SELECT
    Year,
    MAX(CASE WHEN Month = 'Jan' THEN Sales ELSE 0 END) AS Jan,
    MAX(CASE WHEN Month = 'Feb' THEN Sales ELSE 0 END) AS Feb,
    MAX(CASE WHEN Month = 'Mar' THEN Sales ELSE 0 END) AS Mar
FROM
    sales
GROUP BY
    Year;

```

- **列转行：**
	**示例数据**：

	假设有一个库存表 `inventory`：

| Product | Store1 | Store2 | Store3 |
| ------- | ------ | ------ | ------ |
| Apple   | 50     | 30     | 20     |
| Banana  | 60     | 25     | 30     |

我们希望将库存按商店列出：

| Product | Store  | Stock |
| ------- | ------ | ----- |
| Apple   | Store1 | 50    |
| Apple   | Store2 | 30    |
| Apple   | Store3 | 20    |
| Banana  | Store1 | 60    |
| Banana  | Store2 | 25    |
| Banana  | Store3 | 30    |

	在MySQL中，可以使用UNION ALL来实现列转行：
	
```sql
SELECT Product, 'Store1' AS Store, Store1 AS Stock FROM inventory
UNION ALL
SELECT Product, 'Store2' AS Store, Store2 AS Stock FROM inventory
UNION ALL
SELECT Product, 'Store3' AS Store, Store3 AS Stock FROM inventory;

```

- **动态行列转换**
有时候，列的数量或名称可能是动态的。在这种情况下，可以使用动态SQL。以下是一个动态行转列的示例
```sql
SET @sql = NULL;
SELECT
  GROUP_CONCAT(DISTINCT
    CONCAT(
      'MAX(CASE WHEN Month = ''',
      Month,
      ''' THEN Sales ELSE 0 END) AS `',
      Month, '`'
    )
  ) INTO @sql
FROM sales;

SET @sql = CONCAT('SELECT Year, ', @sql, ' FROM sales GROUP BY Year');

PREPARE stmt FROM @sql;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

```